// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import {SafeMath} from "SafeMath.sol";
import {IERC20, ERC20} from "ERC20.sol";
import {Ownable} from "Ownable.sol";

uint256 constant TOTAL_SUPPLY = 10000000000 * 10 ** 18;

contract memeKing is ERC20 {
    event newHolder(address indexed holder);

    using SafeMath for uint256;
    mapping(address => bool) blockList;
    address[] holders;
    address operator;

    modifier onlyOperator() {
        require(msg.sender == operator, "Only Operator");
        _;
    }

    constructor() ERC20("MeMeKing", "MMK") {}

    function init() external {
        require(operator == address(0), "Only onnce");
        operator = msg.sender;
        _mint(operator, TOTAL_SUPPLY);
    }

    function blockAddress(
        address[] memory _address,
        bool _isBlacklisting
    ) external onlyOperator {
        for (uint i = 0; i < _address.length; i++)
            blockList[_address[i]] = _isBlacklisting;
    }

    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        require(!blockList[to] && !blockList[from], "Blocked");

        require(amount > 0, "amount");

        if (to != address(0)) addHolder(to);
    }

    function burn(uint256 value) external {
        _burn(msg.sender, value);
    }

    function airDrop(
        address _memeToken,
        uint256 _amount
    ) external onlyOperator {
        require(
            IERC20(_memeToken).balanceOf(address(this)) >= _amount,
            "No enough fund"
        );
        uint256 _total;

        for (uint i; i < holders.length; i++)
            if (blockList[holders[i]]) continue;
            else _total += balanceOf(holders[i]);

        for (uint i; i < holders.length; i++)
            if (blockList[holders[i]]) continue;
            else
                IERC20(_memeToken).transfer(
                    holders[i],
                    _amount.mul(balanceOf(holders[i])).div(_total)
                );
    }

    function getHolderList()
        external
        view
        onlyOperator
        returns (address[] memory)
    {
        return holders;
    }

    function dryRun(
        uint256 _amount
    )
        external
        view
        onlyOperator
        returns (address[] memory holdersAddress, uint256[] memory cash)
    {
        holdersAddress = new address[](holders.length);
        cash = new uint256[](holders.length);

        uint256 _total;

        for (uint i; i < holders.length; i++)
            if (blockList[holders[i]]) continue;
            else _total += balanceOf(holders[i]);

        for (uint i; i < holders.length; i++)
            if (blockList[holders[i]]) continue;
            else {
                cash[i] = _amount.mul(balanceOf(holders[i])).div(_total);
                holdersAddress[i] = holders[i];
            }
    }

    function addHolder(address _holder) internal {
        if (_holder == operator) return;
        for (uint i; i < holders.length; i++) if (holders[i] == _holder) return;
        holders.push(_holder);

        emit newHolder(_holder);
    }
}


// Generated by /Users/iwan/work/brownie/memeKing/scripts/functions.py